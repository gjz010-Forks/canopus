\section{Evaluation}\label{sec:evaluation}

We further holistically evaluate \canopus\ compared to other scalable SOTA methods, with respect to representative quantum ISAs and hardware topologies. The evaluation not only provides cross-compiler but also cross-ISA comparisons under the coherent basis gate cost and routing overhead settings.


\subsection{Experimental settings}

% \subsubsection{Metrics}
% As we would like to evaluate the qubit routing strategies for diverse quantum ISAs, simple 2Q gate count or circuit depth metrics are not applicable. As each 



% Routing overhead $ C_{\mathrm{routed}} / C_{\mathrm{unrouted}} $

\subsubsection{ISAs and basis gate costs}
We consider six different ISAs (including the conventional \CXISA\ ISA) listed in \Cref{tab:isa_setting}. These mainly cover a wide range of powerful basis gates from $ \CX $-family and $ \iSWAP $-family gates. Particularly, \SQiSWISA~\cite{huang2023quantum} proves to a more powerful ISA option and has been adopted by recent software projects~\cite{mckinney2024mirage,cirqSQiSWDecomposer}. \ZZPhaseISA\ ISA containing three fractional $ \ZZ(\theta) $ rotation gates is adopted by \qiskit's latest synthesis functionalities~\cite{peterson2022optimal,qiskitXXDecomposer}. Mirorr .......... \ZY{TODO: find the initial paper about mirror gate}


\cite{mckinney2024mirage}


We also involve the \HetISA\ ISA that is the composition of \ZZPhaseISA\ and \SQiSWISA.

% cover a wide range of basis gates, including both standard and advanced ones. The basis gate costs are set according to their typical implementation durations on superconducting qubit platforms~\cite{barends2014superconducting,krantz2019quantum,arute2019quantum,foxen2020demonstrating,foxen2021cnot,he2021realization,zhang2023demonstration}, as well as the synthesis costs in terms of \CX\ counts~\cite{vatan2004optimal,shende2004minimal,shende2006synthesis,maslov2008quantum,amy2013meet,yang2020optimal,li2023optimal}.


\begin{table}[tbp]
    \centering
    \caption{Selected quantum ISAs.}
    \begin{footnotesize}
        \input{tables/isa_setting.tex}
    \end{footnotesize}
    \label{tab:isa_setting}
\end{table}









The unit costs for the involved basis gates are set as:
\begin{align}
    \left\{
    \begin{array}{c}
        \CX: 1,\, \ZZ(\pi/t): 2/t,\, \SQiSW: 0.75,\\
        \iSWAP: 1.5,\, \ECP: 1.25,\, \pSWAP(\pi/t): 2-1/t
    \end{array}
    \right\}\label{eq:cost}
\end{align}
\ZY{Plot a weyl chamber to illustrate the cost settings}







\subsubsection{Benchmarks}
We select a set of medium-size benchmarks from QASMBench~\cite{li2023qasmbench} and MQTBench~\cite{quetschlich2023mqt} spanning various categories of quantum programs. These benchmarks first go through logical-level optimization by \tket~\cite{sivarajah2020t} and are rebased to $ \left\{ \Can,\, \Uthree \right\} $ as the input of qubit routing compilers. Information of benchmarks after logical-level optimization are summarized in \Cref{tab:benchmark}, where \dquote{Circuit cost} denotes the circuit duration assuming each canonical gate will be finally rebased to $ \CX $ ISA and the duration (cost) of each $ \CX $ is set to $ 1 $.



\begin{table}[tbp]
    \centering
    \caption{Benchmarks information. These metrics are collected from the circuits after logical-level optimization by \tket, thus including only $\Can$ and $\Uthree$ gates. Circuit cost ($ \countCost $ and $ \depthCost $) is calculated in \CXISA\ ISA.}
    
    \label{tab:benchmark}
    % \setlength{\tabcolsep}{2.5pt}
    % \fontsize{4.6}{5.0}\selectfont
    \begin{footnotesize}
        \input{tables/benchmark_table.tex}
    \end{footnotesize}

\end{table}




\subsubsection{Baselines}




\subsection{Circuit duration reduction}





\begin{table*}[tbp]
    \centering
    \caption{Routing overhead $ \countCost $ for different compilers across different topologies and quantum ISAs.}
    \setlength{\tabcolsep}{1.8pt}
    % \fontsize{4.6}{5.0}\selectfont
    \begin{scriptsize}
        \input{tables/routing_overhead_count.tex}
    \end{scriptsize}

\end{table*}


\begin{table*}[tbp]
    \centering
    \caption{Routing overhead $ \depthCost $ for different compilers across different topologies and quantum ISAs.}
    \setlength{\tabcolsep}{1.8pt}
    % \fontsize{4.6}{5.0}\selectfont
    \begin{scriptsize}
        \input{tables/routing_overhead_depth.tex}
    \end{scriptsize}

\end{table*}







\begin{figure*}[t]
    
    \centering
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/chain_cx.pdf}}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/hhex_cx.pdf}}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/square_cx.pdf}}\vspace{-0.8em}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/chain_zzphase.pdf}}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/hhex_zzphase.pdf}}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/square_zzphase.pdf}}\vspace{-0.8em}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/chain_sqisw.pdf}}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/hhex_sqisw.pdf}}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/square_sqisw.pdf}}\vspace{-0.8em}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/chain_zzphase_.pdf}}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/hhex_zzphase_.pdf}}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/square_zzphase_.pdf}}\vspace{-0.8em}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/chain_sqisw_.pdf}}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/hhex_sqisw_.pdf}}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/square_sqisw_.pdf}}\vspace{-0.8em}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/chain_het.pdf}}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/hhex_het.pdf}}
    \subfigure{\includegraphics[width=0.33\textwidth]{figures/results/square_het.pdf}}

    \caption{Detailed benchmarking results for different compilers (\sabre, \toqm, \bqskit, \canopus) across diverse topologies (columns from left to right: 1D Chain, 2D HHex, 2D Square) and quantum ISAs (rows from top to bottom: \CXISA, \ZZPhaseISA, \SQiSWISA, \ZZPhaseWithMirrorISA, \SQiSWWithMirrorISA, \HetISA). Sizes and colors of the bubbles represent the values for routing overhead (multiples of the routed and rebased circuits compared to that of prior-routing ones).}
    \label{fig:detailed_results}
    
\end{figure*}






\begin{table*}[tbp]
    \centering
    \caption{Summarized results for the routing overhead with average (geometric-mean) values emphasized.}
    \label{tab:summarized_results}

    % \setlength{\tabcolsep}{2.5pt}
    % \begin{scriptsize}
    % \begin{small}
        \input{tables/result_table.tex}
    % \end{scriptsize}
    % \end{small}

\end{table*}



\subsection{Co-exploration of routing and ISA selection}



\subsection{Breakdown analysis}

\subsubsection{Commutative optimization}

In this section, we analyze individual factors in the improvement brought by \canopus, mainly about the commutative optimization mechanism and the heuristic depth-cost weight factor.


\subsubsection{Depth weight factor}



Note that the ...


\ZY{about \code{comm\_opt} effect}





\subsection{Real-system experiments}

\ZY{Fractional gate IBM}

\ZY{QFT or QV test?}


\subsection{For specific gate scheme}

\ZY{For AshN gate scheme}





\subsection{Runtime analysis}

\begin{figure}[tbp]
    \centering
    \includegraphics[width=\columnwidth]{figures/runtime.pdf}
    \caption{Compilation latency comparison.}
    \label{fig:runtime}
\end{figure}

In our field tests for the set of benchmarks above, \canopus\ exhibits around 1x-2x compilation latency than \sabre, both of which are implemented by \qiskit\ framework. This result aligns with the complexity analysis in \Cref{sec:scalability}. Herein we specifically demonstrate the end-to-end compilation latency for larger-scale quantum circuits. We use random quantum volume~\cite{cross2019validating} circuits generated by \qiskit\ for scalability benchmarking, which represents the end of the spectrum with respect to canonical-form circuits. Each canonical gate within the quantum volume circuit contains unique canonical parameters as each 2Q unitary is randomly generated, thus there is no cached synthesis cost calculation for performance improvement in one pass. In the cases of circuit width (number of qubits) set to 15 and 20, we vary the depth of benchmarked circuits from 50 to 200. Quantum volume circuits consists of dense 2Q gates and the largest size for benchmarking is up to thousands of 2Q gates. \Cref{fig:runtime} illustrates the end-to-end compilation latencies, where each data point is tested with the same trial setting (\code{max\_iterations} is 5, both \code{trials} and \code{layout\_trials} are 10). For each benchmarked circuit, \canopus\ leads to on average 1.31x ({\small Â±1\%}) latency than \sabre. Both compilers' latency scales linearly with circuit depth and width. If we compares the curve slopes, \canopus\ leads to 1.32x (1.30x) latency scaling than \sabre\ in terms of circuit depth for \code{qv\_10} (\code{qv\_20}) circuits. Overall, although \canopus\ involves sophisticated data structures and calculation mechanisms, its practical compilation scalability is comparable to the industrial-level \sabre\ algorithm.


% We use two kinds of random circuits generalized by \qiskit---the ordinary random circuit and the quantum volume circuit. They represents the two ends of the spectrum with respect to canonical-form circuits. The ordinary random circuits involves mostly of $ \Can(a,0,0) $ gates and repeated canonical gates according to \qiskit\ built-in \code{random\_circuit} functionality, which leads to commutative optimizations and cached synthesis cost calculation. Quantum volume circuits involves different $ \Can(a,b,c) $ gates as each 2Q unitary gate are randomly generated, which leads to no commutative optimizations and cached synthesis costs. 
% In the cases of circuit width (number of qubits) set to 10 and 20, we vary the depth of benchmarked circuits from 50 to 200. \Cref{fig:runtime} illustrates the end-to-end compilation latencies, where each data point is tested with the same trial setting (\code{max\_iterations} is 5, both \code{trials} and \code{layout\_trials} are 10). For each benchmarked circuit, \canopus\ leads to no more than 1.5x latency than \sabre. Both compilers' latency scales linearly with circuit depth. ...



% \subsection{Robustness analysis}



% (layout trials (max iteration) -- routing)


