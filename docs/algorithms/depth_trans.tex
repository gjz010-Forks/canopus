% \documentclass{article}
% \usepackage[ruled,vlined,linesnumbered]{algorithm2e}
% \usepackage{amsmath} % For \text
% \usepackage{amssymb} % For \Delta

% % Optional: Define a command for code-like text
% \newcommand{\code}[1]{\texttt{#1}}

% \begin{document}

    \begin{algorithm}[tbp]
    \caption{Update $D$ when adding a $ \SWAP $ gate}
    \label{alg:update_durations_swap}

    \SetKwInOut{KwIn}{Input}
    \SetKwInOut{KwOut}{Output}

    \KwIn{
        \code{swap} (encountered SWAP gate), 
        \code{can} (canonical gate within $ L $ on the same qubits as \code{swap}),
        % $D$ (wire durations), 
        % $C$ (commutative pairs within $ L $)
        $ D $, $ C $
    }
    \KwOut{Updated $D$}

    \BlankLine

    % \If{$(\code{swap}.q_0, \code{swap}.q_1) \in C$}{
    %     \tcc{Adjust $ D $ for commutative pair}
    %     $q'_0,\, q'_1 \leftarrow C[(\code{swap}.q_0,\, \code{swap}.q_1)]$\;
    %     \uIf{$\code{swap}.q_0 = q'_0$}{
    %         $D[\code{swap}.q_0] \leftarrow D[q'_0] + \textsc{synthCost}(\text{can})$\;
    %         $D[\code{swap}.q_1] \leftarrow D[\code{swap}.q_0]$\;
    %     }
    %     \ElseIf{$\code{swap}.q_0 = q'_1$}{
    %         $D[\code{swap}.q_0] \leftarrow D[q'_1] + \textsc{synthCost}(\text{can})$\;
    %         $D[\code{swap}.q_1] \leftarrow D[\code{swap}.q_0]$\;
    %     }
    %     \ElseIf{$\code{swap}.q_1 = q'_0$}{
    %         $D[\code{swap}.q_1] \leftarrow D[q'_0] + \textsc{synthCost}(\text{can})$\;
    %         $D[\code{swap}.q_0] \leftarrow D[\code{swap}.q_1]$\;
    %     }
    %     \ElseIf{$\code{swap}.q_1 = q'_1$}{
    %         $D[\code{swap}.q_1] \leftarrow D[q'_1] + \textsc{synthCost}(\text{can})$\;
    %         $D[\code{swap}.q_0] \leftarrow D[\code{swap}.q_1]$\;
    %     }
    % }

    \If{$(\code{swap}.q_0, \code{swap}.q_1) \in C$}{
        % \tcc{Adjust $ D $ for commutative pair}
        $q'_0,\, q'_1 \leftarrow C[(\code{swap}.q_0,\, \code{swap}.q_1)]$\;
        \tcc{Adjust $ D $ by finding matched qubits $q_i \in \{\code{swap}.q_0, \code{swap}.q_1\}$ and $q'_j \in \{q'_0, q'_1\}$}
        $D[q_i] \leftarrow D[q'_j] + \textsc{synthCost}(\text{can})$\;
        $D[\text{the other \code{swap} qubit}] \leftarrow D[q_i]$\;
    }
    % \BlankLine

    % \tcc{Calculate circuit depth increment}
    % $\Delta_{\text{depth}} \leftarrow \textsc{synthCost}(\code{can}.\textsc{mirror}()) - \textsc{synthCost}(\text{can})$\;
    $d \leftarrow \textsc{max}(D[\code{swap}.q_0],\, D[\code{swap}.q_1]) + \textsc{synthCost}(\code{can}.\textsc{mirror}()) - \textsc{synthCost}(\text{can})$\;
    $D[\code{swap}.q_0] \leftarrow d$; $D[\code{swap}.q_1] \leftarrow d$\;

\end{algorithm}

% \end{document}
